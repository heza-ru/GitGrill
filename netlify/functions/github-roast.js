const headers = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'Content-Type',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
  'Content-Type': 'application/json',
};

// Helper function to get GitHub API headers (for potential authentication)
function getGitHubHeaders() {
  const headers = {
    'User-Agent': 'GitGrill-App',
    'Accept': 'application/vnd.github.v3+json',
  };
  
  if (process.env.GITHUB_TOKEN) {
    headers['Authorization'] = `Bearer ${process.env.GITHUB_TOKEN}`;
    console.log('Using authenticated GitHub API (5000 requests/hour)');
  } else {
    console.log('Using unauthenticated GitHub API (60 requests/hour)');
  }
  
  return headers;
}

// Updated harsh roast templates based on the provided examples
const ROAST_TEMPLATES = {
  low_followers: [
    "With a whopping {followers} followers, you've managed to capture the attention of absolutely no one. I bet {followers === 1 ? 'it\'s your mom' : 'they\'re all spam bots'}.",
    "You've got {followers} followers - that's not a following, that's a pity party.",
    "Even your {followers} followers are probably just there out of obligation."
  ],
  
  fork_heavy: [
    "Your entire GitHub is just a graveyard of forks. Not a single original thought. Your creativity amounts to Ctrl+C, Ctrl+V.",
    "With most of your repos being forks, it looks like your programming philosophy is 'why create when you can copy?'",
    "Your GitHub looks like a retirement home for other people's ideas."
  ],
  
  low_activity: [
    "Your last meaningful update was in {lastYear}, and even that was probably just you fixing a typo.",
    "You've been here since {joinYear} and still haven't figured out how Git works.",
    "Your commit history is like a ghost town - lots of promises, zero delivery."
  ],
  
  poor_repos: [
    "Your best repo has {topStars} stars and it's written in {language}. That's not achievement, that's a cry for help.",
    "With {repoCount} repositories, you've mastered the art of quantity over quality.",
    "Your repositories are like your dating life - lots of attempts, zero success."
  ],
  
  single_language: [
    "Only knowing {language}? That's not being specialized, that's being unemployable.",
    "Your entire skill set can be summarized in one word: {language}. Diversify or die.",
    "Coding exclusively in {language} is like only eating plain toast - technically sustenance, but why?"
  ],
  
  emoji_overuse: [
    "Your commit messages read like a teenage girl's diary with all those emojis. Professional much?",
    "Using {emojiPercent}% emojis in commits doesn't make your code better, it makes you look desperate.",
    "Your emoji-to-code ratio suggests you're more interested in decorating than developing."
  ],
  
  generic_repos: [
    "Your '{repoName}' screams originality—oh wait, it doesn't.",
    "A '{repoName}' repo? How refreshingly unoriginal.",
    "Your project names sound like they were generated by an AI having a stroke."
  ],
  
  no_bio: [
    "Zero bio, zero personality, zero excitement. You're the human equivalent of beige.",
    "No bio? Let me guess - you're too mysterious for descriptions or too boring to bother.",
    "Your blank bio perfectly matches your empty repositories."
  ]
};

// Language-specific roasts
const LANGUAGE_ROASTS = {
  'JavaScript': "JavaScript? The language where 'false' == 0 but 'false' !== 0. Perfect choice for someone who enjoys suffering.",
  'Python': "Python? Because why write efficient code when you can pretend indentation is a programming paradigm?",
  'Java': "Java? Still writing enterprise-grade hello world applications, I see.",
  'C++': "C++ - because you enjoy segmentation faults as a hobby.",
  'PHP': "PHP? My condolences to your career prospects.",
  'Go': "Go? Google's attempt to make programming boring succeeded, and you fell for it.",
  'Rust': "Rust? You're that person who mentions being vegan within 5 minutes of meeting someone.",
  'TypeScript': "TypeScript - JavaScript with training wheels for people who can't handle dynamic typing.",
  'Swift': "Swift? Still pretending iOS development is the future?",
  'Kotlin': "Kotlin - Java with makeup. Still ugly underneath.",
  'C#': "C# - Microsoft's Java clone for people who gave up on originality.",
  'Ruby': "Ruby? That's so 2010. What's next, a MySpace profile?",
  'Matlab': "Matlab? Are you a college student or just stuck in 2005?",
  'R': "R? Statistics are fun until you realize no one cares about your data analysis.",
  'Perl': "Perl? I didn't know people still coded in hieroglyphics."
};

function generatePersonalizedRoast(profile, repositories, metrics, analysis) {
  const roastParts = [];
  
  // Opening with name and basic insult
  const name = profile.name || profile.login;
  const joinYear = new Date(profile.created_at).getFullYear();
  const followers = profile.followers;
  const repoCount = profile.public_repos;
  
  // Special case for heza-ru (SearDuck's father)
  if (profile.login.toLowerCase() === 'heza-ru') {
    return `Ah, ${name}, SearDuck's father has graced us with his presence! Even the creator of the roasting duck cannot escape judgment. Your ${repoCount} repositories show that even divine beings struggle with consistency. With ${followers} followers, you've proven that being SearDuck's creator doesn't automatically grant popularity. Your coding journey since ${joinYear} reads like a tragicomedy - brilliant moments followed by questionable decisions. The duck may respect you, but your GitHub statistics... well, they speak for themselves.`;
  }
  
  // Start with name and basic stats
  if (!profile.bio) {
    roastParts.push(`${name}, zero name, zero bio, zero excitement.`);
  } else {
    roastParts.push(`${name}, you've been on GitHub since ${joinYear}`);
  }
  
  // Followers roast
  if (followers <= 1) {
    roastParts.push(`and have managed to gather ${followers} follower${followers !== 1 ? 's' : ''}. ${followers === 1 ? "I bet it's your mom." : "Even spam bots won't follow you."}`);
  } else if (followers < 10) {
    roastParts.push(`and your ${followers} followers are probably just there out of pity.`);
  } else if (followers < 50) {
    roastParts.push(`With ${followers} followers, you're basically the GitHub equivalent of a ghost town.`);
  }
  
  // Repository analysis
  const topRepo = repositories.find(repo => repo.stargazers_count > 0) || repositories[0];
  const totalStars = repositories.reduce((sum, repo) => sum + repo.stargazers_count, 0);
  const forkCount = repositories.filter(repo => repo.fork).length;
  const originalRepos = repositories.filter(repo => !repo.fork);
  
  if (forkCount > originalRepos.length) {
    roastParts.push(`Your entire GitHub is just a graveyard of forks. ${originalRepos.length} original repos versus ${forkCount} forks? Your creativity amounts to Ctrl+C, Ctrl+V.`);
  }
  
  if (topRepo && topRepo.stargazers_count > 0) {
    const mainLanguage = topRepo.language || 'an unknown language';
    roastParts.push(`Your most acclaimed repository is "${topRepo.name}" with ${topRepo.stargazers_count} stars, written in ${mainLanguage}. That's not an achievement, that's a participation award.`);
  } else {
    roastParts.push(`None of your repositories have any stars. That's not humble, that's tragic.`);
  }
  
  // Language-specific roasts
  if (metrics.languages.length === 1) {
    const language = metrics.languages[0];
    roastParts.push(`Only coding in ${language}? ${LANGUAGE_ROASTS[language] || `Specializing in one language isn't expertise, it's limitation.`}`);
  } else if (metrics.languages.length < 3) {
    roastParts.push(`With only ${metrics.languages.length} languages in your arsenal, you're about as versatile as a one-trick pony.`);
  }
  
  // Activity and productivity
  if (metrics.commitFrequency < 10) {
    roastParts.push(`With ${metrics.commitFrequency} commits per month, you code like you're getting paid by the hour and trying to stretch it out.`);
  }
  
  // Emoji usage
  if (metrics.emojiRatio > 0.5) {
    const emojiPercent = Math.round(metrics.emojiRatio * 100);
    roastParts.push(`${emojiPercent}% of your commits contain emojis. This isn't Instagram, it's GitHub. Professional much?`);
  }
  
  // Repository naming
  const genericNames = repositories.filter(repo => 
    /^(test|demo|hello|world|project|repo|untitled|new|my|sample)/i.test(repo.name)
  );
  if (genericNames.length > 0) {
    roastParts.push(`Your "${genericNames[0].name}" repository screams originality—oh wait, it doesn't.`);
  }
  
  // Productivity score roast
  if (metrics.productivityScore <= 3) {
    roastParts.push(`With a productivity score of ${metrics.productivityScore}/10, you're basically the coding equivalent of a participation trophy.`);
  } else if (metrics.productivityScore <= 5) {
    roastParts.push(`A ${metrics.productivityScore}/10 productivity score? You're the embodiment of 'C's get degrees' but for coding.`);
  }
  
  // Empty or abandoned repos
  const emptyRepos = repositories.filter(repo => repo.size === 0);
  if (emptyRepos.length > 0) {
    roastParts.push(`${emptyRepos.length} of your repositories are completely empty. That's not minimalism, that's giving up.`);
  }
  
  // Final harsh conclusion
  const finalInsults = [
    "Congratulations, you've achieved the impossible: making GitHub boring.",
    "Your GitHub profile is a masterclass in mediocrity.",
    "You're like that person at parties who stands in the corner holding a beer, pretending to contribute. Spoiler: you're not.",
    "If coding were an art, you'd be finger painting with your eyes closed.",
    "Your contribution to the programming community is like a null pointer - technically there, but utterly useless."
  ];
  
  roastParts.push(finalInsults[Math.floor(Math.random() * finalInsults.length)]);
  
  return roastParts.join(' ');
}

// Analysis functions
function analyzeCommitFrequency(commits) {
  const recentCommits = commits.length;
  
  if (recentCommits > 50) return { level: 'high', count: recentCommits };
  if (recentCommits < 10) return { level: 'low', count: recentCommits };
  return { level: 'medium', count: recentCommits };
}

function analyzeCommitMessages(commits) {
  const genericWords = ['fix', 'update', 'changes', 'stuff', 'things', 'work', 'test'];
  const shortMessages = commits.filter(commit => commit.message.length < 10);
  const genericMessages = commits.filter(commit => 
    genericWords.some(word => commit.message.toLowerCase().includes(word))
  );
  
  const emojiRegex = /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu;
  const emojiCommits = commits.filter(commit => emojiRegex.test(commit.message));
  
  return {
    generic: genericMessages.length + shortMessages.length,
    total: commits.length,
    emojiCount: emojiCommits.length,
    emojiRatio: commits.length > 0 ? emojiCommits.length / commits.length : 0
  };
}

function analyzeLanguages(repos) {
  const languages = {};
  repos.forEach(repo => {
    if (repo.language) {
      languages[repo.language] = (languages[repo.language] || 0) + 1;
    }
  });
  
  const sortedLanguages = Object.entries(languages)
    .sort(([,a], [,b]) => b - a)
    .map(([lang]) => lang);
    
  return sortedLanguages;
}

function analyzeRepositories(repos) {
  const highlights = [];
  const patterns = [];

  const totalStars = repos.reduce((sum, repo) => sum + repo.stargazers_count, 0);
  const forkCount = repos.filter(repo => repo.fork).length;
  const originalCount = repos.length - forkCount;
  
  highlights.push(`${repos.length} repositories analyzed`);
  highlights.push(`${totalStars} total stars earned`);
  highlights.push(`${originalCount} original vs ${forkCount} forked repositories`);
  
  const staleRepos = repos.filter(repo => {
    const lastUpdate = new Date(repo.updated_at);
    const oneYearAgo = new Date();
    oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
    return lastUpdate < oneYearAgo;
  }).length;
  
  if (staleRepos > 0) {
    highlights.push(`${staleRepos} repositories haven't been touched in over a year`);
  }
  
  const emptyRepos = repos.filter(repo => repo.size === 0).length;
  if (emptyRepos > 0) {
    highlights.push(`${emptyRepos} repositories are completely empty`);
  }
  
  if (forkCount > originalCount) {
    highlights.push('More forks than original work - creativity crisis detected');
  }

  patterns.push(`${repos.length} repositories scanned`);
  patterns.push(`Fork-to-original ratio: ${forkCount}:${originalCount}`);

  return { highlights, patterns };
}

function calculateMetrics(profile, repositories) {
  const totalCommits = repositories.reduce((sum, repo) => sum + (repo.size || 0), 0);
  const monthsSinceJoined = Math.max(1, (Date.now() - new Date(profile.created_at)) / (1000 * 60 * 60 * 24 * 30));
  const commitFrequency = parseFloat((totalCommits / monthsSinceJoined).toFixed(1));

  const languages = [...new Set(repositories
    .map(repo => repo.language)
    .filter(lang => lang)
  )].slice(0, 5);

  const repoNames = repositories.map(repo => repo.name.toLowerCase());
  const emojiPattern = /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu;
  const totalRepos = repositories.length;
  const emojiRepos = repoNames.filter(name => emojiPattern.test(name)).length;
  const emojiRatio = totalRepos > 0 ? emojiRepos / totalRepos : 0;

  let productivityScore = 5;
  if (commitFrequency > 50) productivityScore += 2;
  else if (commitFrequency > 20) productivityScore += 1;
  else if (commitFrequency < 5) productivityScore -= 2;

  if (languages.length > 5) productivityScore += 1;
  else if (languages.length <= 1) productivityScore -= 1;

  if (profile.followers > 100) productivityScore += 1;
  else if (profile.followers < 5) productivityScore -= 1;

  const totalStars = repositories.reduce((sum, repo) => sum + repo.stargazers_count, 0);
  if (totalStars > 50) productivityScore += 1;
  else if (totalStars === 0) productivityScore -= 1;

  productivityScore = Math.max(1, Math.min(10, productivityScore));

  return {
    commitFrequency,
    emojiRatio,
    languages,
    productivityScore
  };
}

exports.handler = async (event, context) => {
  if (event.httpMethod === 'OPTIONS') {
    return { statusCode: 200, headers };
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: 'Method not allowed' }),
    };
  }

  try {
    const { username } = JSON.parse(event.body);

    if (!username) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: 'Username is required' }),
      };
    }

    // Demo mode for rate limiting or testing
    if (username.toLowerCase() === 'demo' || username.toLowerCase() === 'test') {
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
          username: 'demo',
          roast: `🦆💀 BEHOLD! A demo target has appeared! SearDuck's sensors detect this is just a test, but even demo accounts aren't safe from the truth!\n\nYour simulated coding habits show a concerning pattern of perfectionism mixed with demo-worthy mediocrity. SearDuck has analyzed your hypothetical repositories and found them... adequately disappointing!\n\nThe duck's verdict: This demo proves you need GitGrill in your life. Your real GitHub profile probably needs even more roasting than this fake one!`,
          metrics: {
            commitFrequency: 15.3,
            emojiRatio: 0.42,
            languages: ['JavaScript', 'Python', 'TypeScript', 'CSS', 'HTML'],
            productivityScore: 7
          },
          analysis: {
            highlights: [
              '153 commits analyzed - you\'re productive!',
              'Uses 5 programming languages',
              '42% of commits contain emojis',
              'Repository naming could use some work'
            ],
            patterns: ['153 commits analyzed', '23 repositories scanned']
          }
        }),
      };
    }

    console.log(`Fetching profile for username: ${username}`);

    // Fetch user profile
    const profileResponse = await fetch(`https://api.github.com/users/${username}`, {
      headers: getGitHubHeaders(),
    });

    if (!profileResponse.ok) {
      console.log(`Profile fetch failed. Status: ${profileResponse.status}, StatusText: ${profileResponse.statusText}`);
      
      if (profileResponse.status === 404) {
        throw new Error('User not found');
      } else if (profileResponse.status === 403) {
        throw new Error('GitHub API rate limit exceeded. Try username "demo" to see a working example, or wait a few minutes and try again!');
      } else {
        throw new Error('GitHub API temporarily unavailable');
      }
    }

    const profile = await profileResponse.json();
    console.log(`Successfully fetched profile for: ${profile.login}`);

    // Fetch user repositories
    console.log(`Fetching repositories for: ${username}`);
    const reposResponse = await fetch(`https://api.github.com/users/${username}/repos?per_page=100&sort=updated`, {
      headers: getGitHubHeaders(),
    });

    if (!reposResponse.ok) {
      throw new Error(`Failed to fetch repositories: ${reposResponse.statusText}`);
    }

    const repositories = await reposResponse.json();
    console.log(`Found ${repositories.length} repositories for ${username}`);

    // Calculate metrics and analysis
    const metrics = calculateMetrics(profile, repositories);
    const analysis = analyzeRepositories(repositories);

    // Generate personalized roast
    const roast = generatePersonalizedRoast(profile, repositories, metrics, analysis);

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        username: profile.login,
        roast,
        metrics,
        analysis
      }),
    };

  } catch (error) {
    console.error('Error:', error);
    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: error.message || 'Failed to roast. SearDuck is displeased.'
      }),
    };
  }
}; 